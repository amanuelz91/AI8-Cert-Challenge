import logging
import os
from typing import List, Optional, Dict, Any
from tavily import TavilyClient
from dataclasses import dataclass

# Set up logging with third-party noise suppression
from src.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class SearchConfig:
    """Configuration for a Tavily search tool."""
    name: str
    description: str
    domains: List[str]
    max_results: int = 3
    search_depth: str = "advanced"
    include_answer: bool = True
    include_domains: Optional[List[str]] = None
    
    def __post_init__(self):
        """Set include_domains to domains if not provided."""
        if self.include_domains is None:
            self.include_domains = self.domains


class TavilySearchFactory:
    """Factory for creating Tavily search tools with different configurations."""
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize the factory with Tavily API key."""
        self.api_key = api_key or os.getenv("TAVILY_API_KEY")
        if not self.api_key:
            raise ValueError("TAVILY_API_KEY environment variable is required")
        
        self.client = TavilyClient(api_key=self.api_key)
        logger.info("ðŸ”§ TavilySearchFactory initialized")
    
    def create_search_tool(self, config: SearchConfig):
        """
        Create a search tool function based on the provided configuration.
        
        Args:
            config (SearchConfig): Configuration for the search tool
            
        Returns:
            function: A search tool function configured according to the config
        """
        def search_tool(query: str) -> str:
            """
            Search tool generated by TavilySearchFactory.
            
            Args:
                query (str): Search query
                
            Returns:
                str: Formatted search results
            """
            try:
                logger.info(f"ðŸ” [{config.name}] Searching for: {query}")
                
                # Build the search query with domain restrictions
                if len(config.domains) == 1:
                    search_query = f"site:{config.domains[0]} {query}"
                else:
                    domain_sites = " OR ".join([f"site:{domain}" for domain in config.domains])
                    search_query = f"({domain_sites}) {query}"
                
                response = self.client.search(
                    query=search_query,
                    search_depth=config.search_depth,
                    max_results=config.max_results,
                    include_answer=config.include_answer,
                    include_domains=config.include_domains,
                )
                
                logger.info(f"ðŸ“š [{config.name}] Found {len(response.get('results', []))} results")
                
                # Format results
                result = f"{config.name} Search Results for: {query}\n\n"
                
                if response.get("answer") and config.include_answer:
                    result += f"Summary: {response['answer']}\n\n"
                
                result += f"{config.name} Information:\n"
                for i, item in enumerate(response.get("results", []), 1):
                    result += f"{i}. {item.get('title', 'No title')}\n"
                    result += f"   {item.get('content', '')[:200]}...\n"
                    result += f"   URL: {item.get('url', '')}\n\n"
                
                return result
                
            except Exception as e:
                logger.error(f"âŒ [{config.name}] Error: {str(e)}")
                return f"Error searching {config.name}: {str(e)}"
        
        # Add metadata to the function
        search_tool.__name__ = config.name.lower().replace(" ", "_").replace("-", "_")
        search_tool.__doc__ = config.description
        
        return search_tool
    
    def create_multiple_tools(self, configs: List[SearchConfig]) -> Dict[str, Any]:
        """
        Create multiple search tools from a list of configurations.
        
        Args:
            configs (List[SearchConfig]): List of search configurations
            
        Returns:
            Dict[str, Any]: Dictionary mapping tool names to tool functions
        """
        tools = {}
        for config in configs:
            tool_name = config.name.lower().replace(" ", "_").replace("-", "_")
            tools[tool_name] = self.create_search_tool(config)
            logger.info(f"âœ… Created tool: {tool_name}")
        
        return tools


# Convenience function for quick tool creation
def create_tavily_tool(
    name: str,
    description: str,
    domains: List[str],
    max_results: int = 3,
    search_depth: str = "advanced",
    include_answer: bool = True,
    api_key: Optional[str] = None
):
    """
    Convenience function to quickly create a single Tavily search tool.
    
    Args:
        name (str): Tool name
        description (str): Tool description
        domains (List[str]): List of domains to search
        max_results (int): Maximum number of results
        search_depth (str): Search depth ("basic" or "advanced")
        include_answer (bool): Whether to include AI-generated answer
        api_key (Optional[str]): Tavily API key
        
    Returns:
        function: Configured search tool function
    """
    config = SearchConfig(
        name=name,
        description=description,
        domains=domains,
        max_results=max_results,
        search_depth=search_depth,
        include_answer=include_answer
    )
    
    factory = TavilySearchFactory(api_key=api_key)
    return factory.create_search_tool(config)
